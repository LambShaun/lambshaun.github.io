# 指针、引用和动态内存分配

指针、引用和动态内存分配是 C/C++ 语言中最强大的特性，它们允许程序员直接操作内存以高效管理内存——计算机中最关键且稀缺的资源——以获得最佳性能。然而，“指针”也是 C/C++ 语言中最复杂和困难的特性。

指针非常强大，因为它们允许你访问地址并操作其内容。但它们处理起来也非常复杂。正确使用它们，可以极大地提高效率和性能。另一方面，错误使用它们可能会导致许多问题，从难以阅读和维护的代码，到臭名昭著的错误，如内存泄漏和缓冲区溢出，这些可能会使你的系统暴露于黑客攻击之下。许多新语言（如 Java 和 C#）从它们的语法中移除了指针，以避免指针的陷阱，通过提供自动内存管理。

虽然你可以编写 C/C++程序而不使用指针，然而，在教授 C/C++语言时很难不提到指针。指针可能并不适合新手和初学者。

## 1 指针变量

计算机内存位置有一个地址并存储内容。地址是一个数字编号（通常以十六进制表示），程序员直接使用起来很困难。通常，每个地址位置存储 8 位（即 1 字节）的数据。数据的含义，如整数、实数、字符或字符串，完全由程序员来解释。

为了减轻使用数字地址和程序员解释数据的编程负担，早期编程语言（如 C）引入了变量的概念。变量是一个命名的位置，可以存储特定类型的值。不是使用数字地址，而是将名称（或标识符）附加到特定地址上。此外，类型（如 `int` 、 `double` 、 `char` ）与内容相关联，以便于数据的解释。

每个地址位置通常存储 8 位（即 1 字节）的数据。一个 4 字节的 `int` 值占用 4 个内存位置。32 位系统通常使用 32 位地址。要存储一个 32 位地址，需要 4 个内存位置。

下图展示了计算机内存地址与内容之间的关系；以及程序员使用的变量名称、类型和值。

![MemoryAddressContent](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/MemoryAddressContent.png)

### 1.1 指针变量（或指针）

指针变量（简称指针）基本与其他变量相同，可以存储一段数据。与存储值（例如 `int` 、 `double` 、 `char` ）的普通变量不同，指针存储的是内存地址。

### 1.2 声明指针

指针必须在使用前声明，就像普通变量一样。声明指针的语法是在名称前放置一个 `*` 。指针也与类型（如 `int` 和 `double` ）相关联。

```c++
type *ptr;   // Declare a pointer variable called ptr as a pointer of type
// or
type* ptr;
// or
type * ptr;  // I shall adopt this convention
```

For example, 

```c++
int * iPtr;     // Declare a pointer variable called iPtr pointing to an int (an int pointer)
                // It contains an address. That address holds an int value.
double * dPtr;  // Declare a double pointer
```

请注意，您需要在每个指针变量前放置一个 `*` ，换句话说， `*` 仅适用于其后的名称。声明语句中的 `*` 不是运算符，而是表示其后的名称是一个指针变量。例如，

```c++
int *p1, *p2, i;    // p1 and p2 are int pointers. i is an int
int* p1, p2, i;     // p1 is a int pointer, p2 and i are int
int * p1, * p2, i;  // p1 and p2 are int pointers, i is an int
```

**Naming Convention of Pointers:** Include a "`p`" or "`ptr`" as *prefix* or *suffix*, e.g., `iPtr`, `numberPtr`, `pNumber`, `pStudent`.
指针命名约定：包含“ `p` ”或“ `ptr` ”作为前缀或后缀，例如， `iPtr` , `numberPtr` , `pNumber` , `pStudent` 。

### 1.3 通过地址运算符（&）初始化指针

当你声明一个指针变量是，其内容违背初始化。换句话说，它包含一个“某处”的地址，当然这不是一个有效的地址。这是危险的！你需要通过分配一个有效的地址来初始化指针。通常这是通过地址操作符 ( `&` ) 完成的。

地址操作符 ( `&` ) 对变量进行操作，并返回该变量的地址。例如，如果 `number` 是一个 `int` 变量， `&number` 返回变量 `number` 的地址。

您可以使用取地址运算符来获取变量的地址，并将该地址赋值给指针变量。例如，

```c++
int number = 88;     // An int variable with a value
int * pNumber;       // Declare a pointer variable called pNumber pointing to an int (or int pointer)
pNumber = &number;   // Assign the address of the variable number to pointer pNumber
 
int * pAnother = &number; // Declare another int pointer and init to address of the variable number
```

![PointerDeclaration.png](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/PointerDeclaration.png)

如图所示，变量 `int` `number` ，从地址 `0x22ccec` 开始，包含一个 `int` 值 `88` 。表达式 `&number` 返回变量 `number` 的地址，即 `0x22ccec` 。此地址随后被赋值给指针变量 `pNumber` ，作为其初始值。

地址操作符 ( `&` ) 只能在 RHS 上使用。

### 1.4 Indirection or Dereferencing Operator (`*`) 间接或解引用运算符 ( `*` )

间接运算符（或解引用运算符）( `*` ) 对指针进行操作，并返回存储在指针变量中保存的地址中的值。例如，如果 `pNumber` 是一个 `int` 指针， `*pNumber` 返回由 `pNumber` “指向”的 `int` 值。

```c++
int number = 88;
int * pNumber = &number;  
// Declare and assign the address of variable number to pointer pNumber (0x22ccec)
cout << pNumber<< endl;   
// Print the content of the pointer variable, which contain an address (0x22ccec)
cout << *pNumber << endl; 
// Print the value "pointed to" by the pointer, which is an int (88)
*pNumber = 99;            
// Assign a value to where the pointer is pointed to, NOT to the pointer variable
cout << *pNumber << endl; 
// Print the new value "pointed to" by the pointer (99)
cout << number << endl;   
// The value of variable number changes as well (99)
```

请注意， `pNumber` 存储的是内存地址位置，而 `*pNumber` 指的是存储在指针变量中地址的值，或者指针所指向的值。

如图所示，变量（如 `number` ）直接引用一个值，而指针通过其存储的内存地址间接引用一个值。通过指针间接引用一个值称为间接引用或解引用。

间接运算符 ( `*` ) 可用于赋值语句的 RHS ( `temp = *pNumber` ) 和 LHS ( `*pNumber = 99` )。

请注意，符号 `*` 在声明语句和表达式中具有不同的含义。当它用于声明中（例如， `int * pNumber` ）时，表示后面的名称是一个指针变量。而当它用于表达式中（例如， `*pNumber = 99` `; temp << *pNumber;` ）时，则表示指针变量所指向的值。

### 1.5 指针也有类型

指针与它所指向的值的类型相关联，该类型在声明时指定。指针只能保存声明类型的地址；它不能保存不同类型的地址。

```c++
int i = 88;
double d = 55.66;
int * iPtr = &i;    // int pointer pointing to an int value
double * dPtr = &d; // double pointer pointing to a double value
 
iPtr = &d;   // ERROR, cannot hold address of different type
dPtr = &i;   // ERROR
iPtr = i;    // ERROR, pointer holds address of an int, NOT int value
 
int j = 99;
iPtr = &j;  // You can change the address stored in a pointer
```

```c++
#include <iostream>
using namespace std;
 
int main() {
   int number = 88;    // Declare an int variable and assign an initial value
   int * pNumber;      // Declare a pointer variable pointing to an int (or int pointer)
   pNumber = &number;  // assign the address of the variable number to pointer pNumber
 
   cout << pNumber << endl;  // Print content of pNumber (0x22ccf0)
   cout << &number << endl;  // Print address of number (0x22ccf0)
   cout << *pNumber << endl; // Print value pointed to by pNumber (88)
   cout << number << endl;   // Print value of number (88)
 
   *pNumber = 99;            // Re-assign value pointed to by pNumber
   cout << pNumber << endl;  // Print content of pNumber (0x22ccf0)
   cout << &number << endl;  // Print address of number (0x22ccf0)
   cout << *pNumber << endl; // Print value pointed to by pNumber (99)
   cout << number << endl;   // Print value of number (99)
                             // The value of number changes via pointer
 
   cout << &pNumber << endl; // Print the address of pointer variable pNumber (0x22ccec)
}
```

### 1.6 未初始化的指针

以下代码片段存在严重的逻辑错误！

```c++
int * iPtr;
*iPtr = 55;
cout << *iPtr << endl;
```

指针 `iPtr` 被声明时未进行初始化，即它指向 Ascendancy Assistant: 指针 `iPtr` 被声明时未进行初始化，即它指向“某个地方”，当然这是一个无效的内存位置。 `*iPtr = 55` 破坏了“某个地方”的值！您需要通过为其分配一个有效的地址来初始化指针。大多数编译器不会对未初始化的指针发出错误或警告？！

### 1.7 Null Pointers 空指针

你可以将指针初始化为 0 或 `NULL` ，即它不指向任何内容。这被称为空指针。解引用空指针（ `*p` ）会导致 `STATUS_ACCESS_VIOLATION` 异常。

```c++
int * iPtr = 0;         // Declare an int pointer, and initialize the pointer to point to nothing
cout << *iPtr << endl;  // ERROR! STATUS_ACCESS_VIOLATION exception
 
int * p = NULL;         // Also declare a NULL pointer points to nothing
```

在声明时将指针初始化为 null 是一种良好的软件工程实践。

C++11 引入了一个新的关键字 `nullptr` 来表示空指针。

## 2. 引用变量

C++ 添加了所谓的引用变量（简称引用）。引用是一个别名，或者说是现有变量的另一个名称。例如，假设你将 `peter` 设为 `paul` 的引用（别名），你可以称呼这个人既是 `peter` 也是 `paul` 。

引用的主要用途是作为函数形式参数来支持按引用传递。当一个引用变量被传入函数时，函数会直接操作原始副本（而不是按值传递中的克隆副本）。函数内部的更改会在函数外部反映出来。

引用类似于指针。在许多情况下，引用可以作为指针的替代品，特别是在函数参数方面。

### 2.1引用（或别名）（&）

请注意，C/C++ 使用 `&` 来表示表达式中的取地址运算符。C++ 在声明中为 `&` 赋予了额外的含义，用于声明引用变量。

符号 `&` 在表达式和声明中的含义不同。当它用于表达式中时， `&` 表示取地址运算符，返回变量的地址，例如，如果 `number` 是一个 `int` 变量， `&number` 返回变量 `number` 的地址（这一点已在上面章节中描述）。

然而，当 `&` 在声明中（包括函数形式参数）使用时，它是类型标识符的一部分，用于声明引用变量（或引用或别名或替代名称）。它用于提供另一个名称，或另一个引用，或别名给现有变量。

```c++
type &newName = existingName;
// or
type& newName = existingName;
// or
type & newName = existingName;  // I shall adopt this convention
```

应将其理解为“ `newName` 是对 `existingName` 的引用”，或者“ `newNew` 是 `existingName` 的别名”。您现在可以将变量称为 `newName` 或 `existingName` 。

```c++
#include <iostream>
using namespace std;
 
int main() {
   int number = 88;          // Declare an int variable called number
   int & refNumber = number; // Declare a reference (alias) to the variable number
                             // Both refNumber and number refer to the same value
 
   cout << number << endl;    // Print value of variable number (88)
   cout << refNumber << endl; // Print value of reference (88)
 
   refNumber = 99;            // Re-assign a new value to refNumber
   cout << refNumber << endl;
   cout << number << endl;    // Value of number also changes (99)
 
   number = 55;               // Re-assign a new value to number
   cout << number << endl;
   cout << refNumber << endl; // Value of refNumber also changes (55)
}
```



![PointerReferencing](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/PointerReferencing.png)

### 2.2 引用是如何工作的？

引用作为一个指针工作。引用被声明为变量的别名。它存储变量的地址，如图所示：

![ReferenceIsAPointer](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/ReferenceIsAPointer.png)

### 2.3 引用与指针

指针和引用是等价的，除了：

- 引用是一个地址的名称常量。你需要在声明时初始化引用

```c++
int & iRef;   // Error: 'iRef' declared as reference but not initialized
```

一旦对一个变量建立了引用，你就无法更改该引用去引用另一个变量。

- 要获取指针所指向的值，你需要使用解引用操作符 `*` （例如，如果 `pNumber` 是一个 `int` 指针， `*pNumber` 会返回 `pNumber` 所指向的值。这被称为解引用或间接引用）。要将变量的地址赋值给指针，你需要使用取地址操作符 `&` （例如， `pNumber = &number` ）。
- 另一方面，引用和解引用的操作在引用上隐式完成。例如，如果 `refNumber` 是一个指向另一个 `int` 变量的引用（别名）， `refNumber` 会返回该变量的值。不应使用显式的解引用操作符 `*` 。此外，要将变量的地址赋值给引用变量，不需要使用取地址操作符 `&` 。

```c++
#include <iostream>
using namespace std;
 
int main() {
   int number1 = 88, number2 = 22;
 
   // Create a pointer pointing to number1
   int * pNumber1 = &number1;  // Explicit referencing
   *pNumber1 = 99;             // Explicit dereferencing
   cout << *pNumber1 << endl;  // 99
   cout << &number1 << endl;   // 0x22ff18
   cout << pNumber1 << endl;   // 0x22ff18 (content of the pointer variable - same as above)
   cout << &pNumber1 << endl;  // 0x22ff10 (address of the pointer variable)
   pNumber1 = &number2;        // Pointer can be reassigned to store another address
 
   // Create a reference (alias) to number1
   int & refNumber1 = number1;  // Implicit referencing (NOT &number1)
   refNumber1 = 11;             // Implicit dereferencing (NOT *refNumber1)
   cout << refNumber1 << endl;  // 11
   cout << &number1 << endl;    // 0x22ff18
   cout << &refNumber1 << endl; // 0x22ff18
   //refNumber1 = &number2;     // Error! Reference cannot be re-assigned
                                // error: invalid conversion from 'int*' to 'int'
   refNumber1 = number2;        // refNumber1 is still an alias to number1.
                                // Assign value of number2 (22) to refNumber1 (and number1).
   number2++;   
   cout << refNumber1 << endl;  // 22
   cout << number1 << endl;     // 22
   cout << number2 << endl;     // 23
}
```

引用变量为现有变量提供了一个新名称。它会隐式地解除引用，不需要使用解除引用操作符 `*` 来获取引用的值。另一方面，指针变量存储一个地址。你可以更改指针中存储的地址值。要获取指针所指向的值，你需要使用间接操作符 `*` ，这被称为显式解除引用。引用可以被视为一个 `const` 指针。它必须在声明时初始化，并且其内容无法更改。

引用与指针密切相关。在许多情况下，它可以作为指针的替代品。引用允许你使用指针来操作对象，但不需要使用指针的引用和解引用语法。

### 2.4 通过引用传递到具有引用参数与指针参数的函数中

在 C/C++ 中，默认情况下，参数是以值传递的方式传入函数的（数组除外，数组被视为指针）。也就是说，参数会被复制一份副本并传入函数中。在函数内部对副本的修改不会影响调用者中的原始参数。换句话说，被调用的函数无法访问调用者中的变量。例如，

```c++
#include <iostream>
using namespace std;
 
int square(int);
 
int main() {
   int number = 8;
   cout <<  "In main(): " << &number << endl;  // 0x22ff1c
   cout << number << endl;         // 8
   cout << square(number) << endl; // 64
   cout << number << endl;         // 8 - no change
}
 
int square(int n) {  // non-const
   cout <<  "In square(): " << &n << endl;  // 0x22ff00
   n *= n;           // clone modified inside the function
   return n;
}
```

输出清楚地显示有两个不同的地址。

##### Pass-by-Reference with Pointer Arguments 使用指针参数的按引用传递

在许多情况下，我们可能希望直接修改原始副本（特别是在传递大型对象或数组时），以避免克隆的开销。这可以通过将对象的指针传递到函数中来实现，称为按引用传递。例如，

```c++
#include <iostream>
using namespace std;
 
void square(int *);
 
int main() {
   int number = 8;
   cout <<  "In main(): " << &number << endl;  // 0x22ff1c
   cout << number << endl;   // 8
   square(&number);          // Explicit referencing to pass an address
   cout << number << endl;   // 64
}
 
void square(int * pNumber) {  // Function takes an int pointer (non-const)
   cout <<  "In square(): " << pNumber << endl;  // 0x22ff1c
   *pNumber *= *pNumber;      // Explicit de-referencing to get the value pointed-to
}
```

被调用的函数在相同的地址上操作，因此可以修改调用者中的变量。

##### Pass-by-Reference with Reference Arguments 通过引用传递与引用参数

除了将指针传入函数外，你还可以将引用传入函数，以避免引用和解引用的繁琐语法。例如，

```c++
#include <iostream>
using namespace std;
 
void square(int &);
 
int main() {
   int number = 8;
   cout <<  "In main(): " << &number << endl;  // 0x22ff1c
   cout << number << endl;  // 8
   square(number);          // Implicit referencing (without '&')
   cout << number << endl;  // 64
}
 
void square(int & rNumber) {  // Function takes an int reference (non-const)
   cout <<  "In square(): " << &rNumber << endl;  // 0x22ff1c
   rNumber *= rNumber;        // Implicit de-referencing (without '*')
}
```

再次，输出显示被调用的函数在同一地址上操作，因此可以修改调用者的变量。

请注意，引用（在调用者中）和解引用（在函数中）是隐式完成的。与按值传递的唯一编码区别在于函数的参数声明中。

请记住，引用必须在声明时初始化。在函数形参的情况下，引用在函数被调用时初始化为调用者的参数。

引用主要用于在函数间传递引用，以便被调用的函数直接访问调用者的变量。

引用主要用于在函数间传递引用，以便被调用的函数直接访问调用者的变量。

##### "const" Function Reference/Pointer Parameters "const" 函数引用/指针参数

一个 `const` 函数形式参数在函数内部不能被修改。尽可能使用 `const` ，因为它可以防止你无意中修改参数，并保护你免受许多编程错误的影响。

一个 `const` 函数形式参数在函数内部不能被修改。尽可能使用 `const` ，因为它可以防止你无意中修改参数，并保护你免受许多编程错误的影响。

```c++
#include <iostream>
using namespace std;
 
int squareConst(const int);
int squareNonConst(int);
int squareConstRef(const int &);
int squareNonConstRef(int &);
 
int main() {
   int number = 8;
   const int constNumber = 9;
   cout << squareConst(number) << endl;
   cout << squareConst(constNumber) << endl;
   cout << squareNonConst(number) << endl;
   cout << squareNonConst(constNumber) << endl;
 
   cout << squareConstRef(number) << endl;
   cout << squareConstRef(constNumber) << endl;
   cout << squareNonConstRef(number) << endl;
   // cout << squareNonConstRef(constNumber) << endl;
       // error: invalid initialization of reference of
       //  type 'int&' from expression of type 'const int'
}
 
int squareConst(const int number) {
   // number *= number;  // error: assignment of read-only parameter
   return number * number;
}
 
int squareNonConst(int number) {  // non-const parameter
   number *= number;
   return number;
}
 
int squareConstRef(const int & number) {  // const reference
   return number * number;
}
 
int squareNonConstRef(int & number) {  // non-const reference
   return number * number;
}
```

### 2.5 传递函数的返回值

##### Passing the Return-value as Reference 将返回值作为引用传递

也可以将返回值作为引用或指针传递。例如，

```c++
#include <iostream>
using namespace std;
 
int & squareRef(int &);
int * squarePtr(int *);
 
int main() {
   int number1 = 8;
   cout <<  "In main() &number1: " << &number1 << endl;  // 0x22ff14
   int & result = squareRef(number1);
   cout <<  "In main() &result: " << &result << endl;  // 0x22ff14
   cout << result << endl;   // 64
   cout << number1 << endl;  // 64
 
   int number2 = 9;
   cout <<  "In main() &number2: " << &number2 << endl;  // 0x22ff10
   int * pResult = squarePtr(&number2);
   cout <<  "In main() pResult: " << pResult << endl;  // 0x22ff10
   cout << *pResult << endl;   // 81
   cout << number2 << endl;    // 81
}
 
int & squareRef(int & rNumber) {
   cout <<  "In squareRef(): " << &rNumber << endl;  // 0x22ff14
   rNumber *= rNumber;
   return rNumber;
}
 
int * squarePtr(int * pNumber) {
   cout <<  "In squarePtr(): " << pNumber << endl;  // 0x22ff10
   *pNumber *= *pNumber;
   return pNumber;
}
```

##### 你不应该将函数的局部变量作为返回值按引用传递

```c++
#include <iostream>
using namespace std;
 
int * squarePtr(int);
int & squareRef(int);
 
int main() {
   int number = 8;
   cout << number << endl;  // 8
   cout << *squarePtr(number) << endl;  // ??
   cout << squareRef(number) << endl;   // ??
}
 
int * squarePtr(int number) {
   int localResult = number * number;
   return &localResult;
      // warning: address of local variable 'localResult' returned
}
 
int & squareRef(int number) {
   int localResult = number * number;
   return localResult;
      // warning: reference of local variable 'localResult' returned
}
```

这个程序存在严重的逻辑错误，因为函数的局部变量被作为返回值通过引用传递回去。局部变量在函数内具有局部作用域，其值在函数退出后会被销毁。GCC 编译器很友好地发出了警告（但不是错误).

将作为参数传递给函数的引用返回是安全的。请参见之前的示例

### 2.6 总结

指针和引用非常复杂且难以掌握。它们可以极大提高程序的效率

对于新手来说，避免在程序中使用指针。不当使用可能会导致严重的逻辑错误。然而，你需要理解使用指针和引用的传引用语法的知识，因为它们在许多库函数中被使用。

- 在按值传递中，会创建一个副本并传递给函数。调用者的副本无法被修改。
- 在按引用传递中，指针被传递到函数中。调用者的副本可能在函数内部被修改。
- 在通过引用传递参数时，你使用变量名作为参数。
- 在使用指针参数的按引用传递中，你需要使用 `&varName` （一个地址）作为参数。

## 3动态内存分配

### 3.1 `new`和`delete`运算符

`new` 操作返回一个指向已分配内存的指针。 `delete` 运算符以一个指针（指向通过 `new` 分配的内存）作为其唯一参数。

```c++
int number = 88;
int * p1 = &number;  // Assign a "valid" address into pointer
 
// Dynamic Allocation
int * p2;            // Not initialize, points to somewhere which is invalid
cout << p2 << endl; // Print address before allocation
p2 = new int;       // Dynamically allocate an int and assign its address to pointer
                    // The pointer gets a valid address with memory allocated
*p2 = 99;
cout << p2 << endl;  // Print address after allocation
cout << *p2 << endl; // Print value point-to
delete p2;           // Remove the dynamically allocated storage
```

请注意， `new` 和 `delete` 运算符作用于指针。

要初始化分配的内存，可以使用基本类型的初始化器，或者为对象调用构造函数。例如，

```c++
// use an initializer to initialize a fundamental type (such as int, double)
int * p1 = new int(88);
double * p2 = new double(1.23);
 
// C++11 brace initialization syntax
int * p1 = new int {88};
double * p2 = new double {1.23};
 
// invoke a constructor to initialize an object (such as Date, Time)
Date * date1 = new Date(1999, 1, 1);  
Time * time1 = new Time(12, 34, 56);
```

可以在函数内部为全局指针动态分配存储空间。函数内部动态分配的存储空间在函数退出后仍然存在。例如，

```c++
#include <iostream>
using namespace std;
 
int * p1, * p2;  // Global int pointers
 
// This function allocates storage for the int*
// which is available outside the function
void allocate() {
   p1 = new int;     // Allocate memory, initial content unknown
   *p1 = 88;         // Assign value into location pointed to by pointer
   p2 = new int(99); // Allocate and initialize
}
 
int main() {
   allocate();
   cout << *p1 << endl;  // 88
   cout << *p2 << endl;  // 99
   delete p1;  // Deallocate
   delete p2;
   return 0;
}
```

静态分配和动态分配之间的主要区别是：

- 在静态分配中，编译器会自动分配和释放存储空间，并处理内存管理。而在动态分配中，作为程序员的你需要自己处理内存的分配和释放（通过 `new` 和 `delete` 操作符）。你对指针地址及其内容以及内存管理有完全的控制。
- 静态分配的实体通过命名变量进行操作。动态分配的实体通过指针进行处理。

### 3.2 new[] 和 delete[] 运算符

动态数组在运行时而不是编译时分配，通过 `new[]` 运算符。要移除存储空间，你需要使用 `delete[]` 运算符（而不是简单地使用 `delete` ）。例如，

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
 
int main() {
   const int SIZE = 5;
   int * pArray;
 
   pArray = new int[SIZE];  // Allocate array via new[] operator
 
   // Assign random numbers between 0 and 99
   for (int i = 0; i < SIZE; ++i) {
      *(pArray + i) = rand() % 100;
   }
   // Print array
   for (int i = 0; i < SIZE; ++i) {
      cout << *(pArray + i) << " ";
   }
   cout << endl;
 
   delete[] pArray;  // Deallocate array via delete[] operator
   return 0;
}
```

C++03 不允许您初始化动态分配的数组。C++11 允许使用大括号初始化，如下所示：

```c++
// C++11
int * p = new int[5] {1, 2, 3, 4, 5};
```

## 4.指针、数组和函数

### 4.1数组被视为指针

在 C/C++ 中，数组的名称是一个指针，指向数组的第一个元素（索引 0）。例如，假设 `numbers` 是一个 `int` 数组， `numbers` 也是一个 `int` 指针，指向数组的第一个元素。也就是说， `numbers` 与 `&numbers[0]` 是相同的。因此， `*numbers` 是 `number[0]` ； `*(numbers+i)` 是 `numbers[i]` 。

```c++
#include <iostream>
using namespace std;
 
int main() {
   const int SIZE = 5;
   int numbers[SIZE] = {11, 22, 44, 21, 41};  // An int array
 
   // The array name numbers is an int pointer, pointing at the
   // first item of the array, i.e., numbers = &numbers[0]
   cout << &numbers[0] << endl; // Print address of first element (0x22fef8)
   cout << numbers << endl;     // Same as above (0x22fef8)
   cout << *numbers << endl;         // Same as numbers[0] (11)
   cout << *(numbers + 1) << endl;   // Same as numbers[1] (22)
   cout << *(numbers + 4) << endl;   // Same as numbers[4] (41)
}
```

### 4.2 指针运算

如前一节所述，如果 `numbers` 是一个 `int` 数组，它将被视为一个指向数组第一个元素的 `int` 指针。 `(numbers + 1)` 指向下一个 `int` ，而不是具有下一个连续地址。请注意，一个 `int` 通常有 4 个字节。也就是说， `(numbers + 1)` 将地址增加 4，或者 `sizeof(int)` 。例如，

```c++
int numbers[] = {11, 22, 33};
int * iPtr = numbers;
cout << iPtr << endl;        // 0x22cd30
cout << iPtr + 1 << endl;    // 0x22cd34 (increase by 4 - sizeof int)
cout << *iPtr << endl;       // 11
cout << *(iPtr + 1) << endl; // 22 
cout << *iPtr + 1 << endl;   // 12
```

### 4.3 `size of`数组

操作 `sizeof(arrayName)` 返回数组的总字节数。您可以通过将其除以单个元素的大小（例如元素 0 的大小）来推导出数组的长度（大小）。例如，

```c++
int numbers[100];
cout << sizeof(numbers) << endl;     
// Size of entire array in bytes (400)
cout << sizeof(numbers[0]) << endl;  
// Size of first element of the array in bytes (4)
cout << "Array size is " << sizeof(numbers) / sizeof(numbers[0]) << endl;  // (100)
```

### 4.4 将数组传入/传出函数

一个数组作为指向数组第一个元素的指针传递给函数。你可以在函数声明中使用数组表示法（例如， `int[]` ）或指针表示法（例如， `int*` ）。编译器总是将其视为指针（例如， `int*` ）。例如，以下声明是等效的：

```c++
int max(int numbers[], int size);
int max(int *numbers, int size);
int max(int number[50], int size);
```

它们将被编译器视为 `int*` ，如下所示。 `[]` 中给出的数组大小将被忽略。

```c++
int max(int*, int);
```

数组通过引用传递到函数中，因为传递的是指针而不是克隆副本。如果在函数内部修改了数组，这些修改将应用到调用者的副本上。你可以将数组参数声明为 `const` 以防止数组在函数内部被修改。

数组的大小不是数组参数的一部分，需要在另一个 `int` 参数中传递。编译器无法从数组指针推断数组大小，也不会执行数组边界检查。

示例：使用通常的数组表示法。

```c++
#include <iostream>
using namespace std;
 
// Function prototypes
int max(const int arr[], int size);
void replaceByMax(int arr[], int size);
void print(const int arr[], int size);
 
int main() {
   const int SIZE = 4;
   int numbers[SIZE] = {11, 22, 33, 22};
   print(numbers, SIZE);
   cout << max(numbers, SIZE) << endl;
   replaceByMax(numbers, SIZE);
   print(numbers, SIZE);
}
 
// Return the maximum value of the given array.
// The array is declared const, and cannot be modified inside the function.
int max(const int arr[], int size) {
   int max = arr[0];
   for (int i = 1; i < size; ++i) {
      if (max < arr[i]) max = arr[i];
   }
   return max;
}
 
// Replace all elements of the given array by its maximum value
// Array is passed by reference. Modify the caller's copy.
void replaceByMax(int arr[], int size) {
   int maxValue = max(arr, size);
   for (int i = 0; i < size; ++i) {
      arr[i] = maxValue;
   }
}
 
// Print the array's content
void print(const int arr[], int size) {
   cout << "{";
   for (int i = 0; i < size; ++i) {
      cout << arr[i];
      if (i < size - 1) cout << ",";
   }
   cout << "}" << endl;
}
```

请注意，您可以在函数内部修改调用者的数组内容，因为数组是按引用传递的。为了防止意外修改，您可以对函数参数应用 `const` 限定符。请记住， `const` 会告知编译器该值不应被更改。例如，假设函数 `print()` 打印给定数组的内容且不修改数组，您可以对数组名称及其大小都应用 `const` ，因为它们在函数内部不应被更改。

```c++
void print(const int arr[], int size);
```

编译器会标记一个错误“赋值只读位置”，如果它检测到 `const` 值将被更改。

使用指针表示法。

```c++
#include <iostream>
using namespace std;
 
// Function prototype
int max(const int *arr, int size);
 
int main() {
   const int SIZE = 5;
   int numbers[SIZE] = {10, 20, 90, 76, 22};
   cout << max(numbers, SIZE) << endl;
}
 
// Return the maximum value of the given array
int max(const int *arr, int size) {
   int max = *arr;
   for (int i = 1; i < size; ++i) {
      if (max < *(arr+i)) max = *(arr+i);
   }
   return max;
}
```

### 4.5 按引用传递和`size of`

```c++
#include <iostream>
using namespace std;
 
// Function prototypes
void fun(const int *arr, int size);
 
// Test Driver
int main() {
   const int SIZE = 5;
   int a[SIZE] = {8, 4, 5, 3, 2};
   cout << "sizeof in main() is " << sizeof(a) << endl;
   cout << "address in main() is " << a << endl;
   fun(a, SIZE);
}
 
// Function definitions
void fun(const int *arr, int size) {
   cout << "sizeof in function is " << sizeof(arr) << endl;
   cout << "address in function is " << arr << endl;
}
```

````
sizeof in main() is 20
address in main() is 0x22fefc
sizeof in function is 4
address in function is 0x22fefc
````

数组在 `main()` 中的地址和函数中的地址相同，正如预期的那样，因为数组是按引用传递的。

在 `main()` 中， `sizeof` 数组是 20（每个 `int` 4 字节，长度为 5）。在函数内部， `sizeof` 是 4，这是 `sizeof` `int` 指针（4 字节地址）。这就是为什么你需要将大小传递到函数中。

### 4.6 在数组的范围内进行操作

```c++
#include <iostream>
using namespace std;
 
// Function prototype
int sum(const int *begin, const int *end);
 
// Test Driver
int main() {
   int a[] = {8, 4, 5, 3, 2, 1, 4, 8};
   cout << sum(a, a+8) << endl;        // a[0] to a[7]
   cout << sum(a+2, a+5) << endl;      // a[2] to a[4]
   cout << sum(&a[2], &a[5]) << endl;  // a[2] to a[4]
}
 
// Function definition
// Return the sum of the given array of the range from
// begin to end, exclude end.
int sum(const int *begin, const int *end) {
   int sum = 0;
   for (const int *p = begin; p != end; ++p) {
      sum += *p;
   }
   return sum;
}
```

- 要编写一个对给定数组的某个范围进行操作的函数，你可以将开始指针和结束指针传递给该函数。按照惯例，操作应从开始指针开始，直到结束指针，但不包括结束指针。

- 在“ `const int *p` ”中， `*p` （指向的内容）是恒定的，但 `p` 不是恒定的。

### 4.7 C-String 和指针

C-string（C 语言中的）是一个字符数组，以空字符 `'\0'` 作为结束标志。例如，

```c++
#include <iostream>
#include <cstring>
using namespace std;
 
int main() {
   char msg1[] = "Hello";
   char *msg2 = "Hello";
      // warning: deprecated conversion from string constant to 'char*'
 
   cout << strlen(msg1) << endl;    // 5
   cout << strlen(msg2) << endl;
   cout << strlen("Hello") << endl;
 
   int size = sizeof(msg1)/sizeof(char);
   cout << size << endl;  // 6 - including the terminating '\0'
   for (int i = 0; msg1[i] != '\0'; ++i) {
      cout << msg1[i];
   }
   cout << endl;
 
   for (char *p = msg1; *p != '\0'; ++p) {
          // *p != '\0' is the same as *p != 0, is the same as *p
      cout << *p;
   }
   cout << endl;
}
```

请注意，对于 C-String 函数，例如 `strlen()` （在头文件 `cstring` 中，从 C 的 `string.h` 移植过来），无需将数组长度传递给函数。这是因为 C-Strings 以 `'\0'` 结尾。函数可以遍历数组中的字符，直到 `'\0'` 。例如，

```c++
#include <iostream>
#include <cstring>
using namespace std;
 
int count(const char *str, const char c);  // No need to pass the array size
 
int main() {
   char msg1[] = "Hello, world";
   char *msg2 = "Hello, world";
 
   cout << count(msg1, 'l') << endl;
   cout << count(msg2, 'l') << endl;
   cout << count("Hello, world", 'l') << endl;
}
 
// Count the occurrence of c in str
// No need to pass the size of char[] as C-string is terminated with '\0'
int count(const char *str, const char c) {
   int count = 0;
   while (*str) {   // same as (*str != '\0')
      if (*str == c) ++count;
      ++str;
   }
   return count;
}
```

## **5更多关于指针的内容**

### 5.1 函数指针

在 C/C++ 中，函数像所有数据项一样，都有一个地址。函数的名称是函数在内存中的起始地址，因此可以被视为一个指针。我们也可以将函数指针传递给函数。声明函数指针的语法是：

```c++
// Function-pointer declaration
return-type (* function-ptr-name) (parameter-list)
 
// Examples
double (*fp)(int, int)  // fp points to a function that takes two ints and returns a double (function-pointer)
double *dp;             // dp points to a double (double-pointer)
double *fun(int, int)   // fun is a function that takes two ints and returns a double-pointer

double f(int, int);      // f is a function that takes two ints and returns a double
fp = f;                 
```

```c++
#include <iostream>
using namespace std;
 
int arithmetic(int, int, int (*)(int, int));
    // Take 3 arguments, 2 int's and a function pointer
    //   int (*)(int, int), which takes two int's and return an int
int add(int, int);
int sub(int, int);
 
int add(int n1, int n2) { return n1 + n2; }
int sub(int n1, int n2) { return n1 - n2; }
 
int arithmetic(int n1, int n2, int (*operation) (int, int)) {
   return (*operation)(n1, n2);
}
 
int main() {
   int number1 = 5, number2 = 6;
 
   // add
   cout << arithmetic(number1, number2, add) << endl;
   // subtract
   cout << arithmetic(number1, number2, sub) << endl;
}
```

### 5.2 通用指针或空指针 (void *)

一个 `void` 指针可以持有任何数据类型的地址（函数指针除外）。我们无法对 `void` 指针所指向的对象进行操作，因为类型未知。我们可以使用 `void` 指针与其他地址进行比较。

### 5.3 常量指针与常量指向数据

1. 非恒定指针指向恒定数据：指向的数据不能被更改；但指针可以被更改以指向其他数据。例如，

   ```c++
   int i1 = 8, i2 = 9;
   const int * iptr = &i1;  // non-constant pointer pointing to constant data
   // *iptr = 9;   // error: assignment of read-only location
   iptr = &i2;  // okay
   ```

2. 指向非常量数据的常量指针：指向的数据可以被更改；但指针不能被更改以指向其他数据。例如，

   ```c++
   int i1 = 8, i2 = 9;
   int * const iptr = &i1;  // constant pointer pointing to non-constant data
                            // constant pointer must be initialized during declaration
   *iptr = 9;   // okay
   // iptr = &i2;  // error: assignment of read-only variable
   ```

3. 指向常量数据的常量指针：指向的数据不能被更改；指针也不能被更改以指向其他数据。例如，

   ```c++
   int i1 = 8, i2 = 9;
   const int * const iptr = &i1;  // constant pointer pointing to constant data
   // *iptr = 9;   // error: assignment of read-only variable
   // iptr = &i2;  // error: assignment of read-only variable
   ```

4. 非恒定指针指向非恒定数据：指向的数据可以被更改；指针也可以被更改以指向其他数据。例如，

   ```c++
   int i1 = 8, i2 = 9;
   int * iptr = &i1;  // non-constant pointer pointing to non-constant data
   *iptr = 9;   // okay
   iptr = &i2;  // okay
   ```

