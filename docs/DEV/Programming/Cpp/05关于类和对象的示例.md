# 关于类和对象的示例

## 1 示例：时间类版本2 ——使用引用

继我们之前的 Time 类版本之后，假设我们希望支持对 `Time` 实例进行级联操作，例如 `t.nextSecond().nextSecond().print()` 。我们可以让 `nextSecond()` 通过引用返回“ `this` ”实例。级联操作 `t.nextSecond().nextSecond().print()` 应被理解为 `((t.nextSecond()).nextSecond()).print()` 。 `t.nextSecond()` 返回对“ `this` ” ``实例的引用，然后该引用用于调用第二个操作，依此类推。

##### Time.h

```c++
class Time {
private:
   ......
public:
   Time & nextSecond();  // Return a reference to "this" instance
   ......
};
```

在函数原型中，我们声明 `nextSecond()` 成员函数返回对 `Time` 对象的引用。返回的引用可用于调用类的成员函数。例如， `t.nextSecond().nextSecond()` 被解释为 `(t.nextSecond()).nextSecond()` 。我们之前的版本返回 `void` ，无法进一步使用。

```c++
// Increase this instance by one second and return this instance by reference
Time & Time::nextSecond() {
   if (++second == 60) {
      second = 0;
      if (++minute == 60) {
         minute = 0;
         if (++hour == 24) {
            hour = 0;
         }
      }
   }
   return *this;  // Return this instance by reference
                  // "this" is a pointer to this instance. *this refers to this instance.
}
```

C++ 有一个特殊的关键词 `this` ，它包含指向此实例的指针。因此， `*this` 指的是此实例，该实例通过引用返回给调用者，对应于返回类型 `Time &` 。

**TestTime.cpp**

```c++
Time t1(23, 59, 58);
t1.print();     // 23:59:58
t1.nextSecond();
t1.print();     // 23:59:59
t1.nextSecond().nextSecond().print();  // 00:00:01
t1.print();     // 00:00:01
```

##### Exercise 练习

尝试修改 `setHour()` 、 `setMinute()` 和 `setSecond()` 以支持如 `aTime.setHour(22).setMinute(29).setSecond(20).print()` 之类的级联操作。

## 2. 示例：时间类版本 3 - 异常处理

输入验证是必要的。例如，在 `setHour(int h)` 中，我们应该检查给定的输入 `h` 是否在 0 到 23 之间。检查输入很简单，但如果输入无效该怎么办却很棘手。例如，我们可以打印一条错误消息并突然终止程序（通过 `<cstdlib>` 中的 `exit(1)` ）；我们也可以打印一条警告消息，将小时设置为 0，并继续程序，但小时值可能并不是期望的。这两种方法都不太理想。

```c++
void Time::setHour(int h) {
   if (h >= 0 && h <= 23) {
      hour = h;
   } else {
      cout << "Error: Invalid hour! Hour shall be 0-23." << endl;
      exit(1);  // Terminate the program abruptly!!!
   }
}
```

```c++
void Time::setHour(int h) {
   if (h >= 0 && h <= 23) {
      hour = h;
   } else {
      cout << "Warning: Invalid hour! Hour shall be 0-23. Set to 0." << endl;
      hour = 0;  // Program continues with a hour value may or may not be desired?
   }
}
```

相反，C++ 提供了一个异常处理机制（在头文件 `<stdexcept>` 中），以适当且优雅地处理异常。让我们修改代码，使用 C++ 异常处理机制进行输入验证。

##### Time.h

```c++
/* Header for the Time class (Time.h) */
#ifndef TIME_H
#define TIME_H
 
class Time {
private:
   int hour;     // 0 - 23
   int minute;   // 0 - 59
   int second;   // 0 - 59
 
public:
   Time(int h = 0, int m = 0, int s = 0);
   int getHour() const;
   void setHour(int h);
   int getMinute() const;
   void setMinute(int m);
   int getSecond() const;
   void setSecond(int s);
   void setTime(int h, int m, int s);
   void print() const;
};
 
#endif
```

##### Time.h

```c++
/* Implementation for the Time Class (Time.cpp) */
#include <iostream>
#include <iomanip>
#include <stdexcept>    // Needed for exception handling
#include "Time.h"
using namespace std;
 
Time::Time(int h, int m, int s) {
   // Call setters to perform input validation
   setHour(h);
   setMinute(m);
   setSecond(s);
}
 
int Time::getHour() const {
   return hour;
}
 
void Time::setHour(int h) {  // with input validation
   if (h >= 0 && h <= 23) {
      hour = h;
   } else {
      throw invalid_argument("Invalid hour! Hour shall be 0-23.");
            // need <stdexcept>
   }
}
 
int Time::getMinute() const {
   return minute;
}
 
void Time::setMinute(int m) {
   if (m >= 0 && m <= 59) {
      minute = m;
   } else {
      throw invalid_argument("Invalid minute! Minute shall be 0-59.");
            // need <stdexcept>
   }
}
 
int Time::getSecond() const {
   return second;
}
 
void Time::setSecond(int s) {
   if (s >= 0 && s <= 59) {
      second = s;
   } else {
      throw invalid_argument("Invalid second! Second shall be 0-59.");
            // need <stdexcept>
   }
}
 
void Time::setTime(int h, int m, int s) {
   // Call setters to validate inputs
   setHour(h);
   setMinute(m);
   setSecond(s);
}
 
void Time::print() const {
   cout << setfill('0');
   cout << setw(2) << hour << ":" << setw(2) << minute << ":"
        << setw(2) << second << endl;
}
```

Program Notes:

````c++
void Time::setHour(int h)
   if (h >= 0 && h <= 23) {
      hour = h;
   } else {
      throw invalid_argument("Invalid hour! Hour shall be 0-23.");
   }
}
````

我们将通过 `setHour()` 成员函数来说明输入验证。如果 `h` 是一个有效的小时数，它会将给定的 `h` 赋值给 `hour` 。否则，我们使用 C++ 异常处理机制抛出一个类型为 `invalid_argument` 的异常对象（在 `<stdexcept>` 头文件中定义）。这允许调用者捕获异常并优雅地处理异常情况（将在后续的测试驱动程序中进一步说明）。

````c++
Time::Time(int h, int m, int s) {
   setHour(h);
   setMinute(m);
   setSecond(s);
}
````

在构造函数中，我们调用了 `setHour()` 、 `setMinute()` 和 `setSecond()` ，它们执行输入验证，而不是直接赋值。我们还以类似的方式修改了 `setTime()` 。

##### TestTime.cpp

```c++
/* Test Driver for the Time class (TestTime.cpp) */
#include <iostream>
#include <stdexcept>  // Needed for exception handling
#include "Time.h"
using namespace std;
 
int main() {
   //   Time t2(25, 0, 0); // program terminates abruptly
   //   t2.print();        // The rest of program will not be run
 
   // Graceful handling of exception
   try {
      Time t1(25, 0, 0); // Skip the remaining statements in try-clause and
                         // jump to catch-clause if an exception is thrown
      t1.print();
         // Continue to the next statement after try-catch, if there is no exception
   } catch (invalid_argument& ex) {  // need <stdexcept>
      cout << "Exception: " << ex.what() << endl;
         // Continue to the next statement after try-catch
   }
   cout << "Next statement after try-catch" << endl;
}
```

Program Notes: 程序说明：

````c++
Time t1(25, 0, 0); 
````

如果你运行上述语句（取消第 8 行和第 9 行的注释）而不捕获异常，程序会突然终止（即，剩余的语句将不会被执行），并显示以下错误消息：

````c++
terminate called after throwing an instance of 'std::invalid_argument'
  what():  Invalid hour! Hour shall be 0-23.
````

````c++
try {
   Time t2(25, 0, 0);
   t2.print();
} catch (invalid_argument& ex) {
   cout << "Exception: " << ex.what() << endl;
}
````

然而，如果您像上面那样将语句包含在 try-catch 结构中，当 try 子句中的某个语句发生异常时，try 子句中的剩余语句将被跳过，控制权转移到 catch 子句。在这种情况下，catch 子句会捕获抛出的 `invalid_argument` 异常，执行 catch 体内的代码。然后程序会继续执行 try-catch 之后的下一条语句。通过这种方式，您的程序可以优雅地处理异常情况（例如，关闭文件和资源），而不是突然终止。

## 3. 对象引用、指针和动态分配数组（高级）

我们将使用上面的 `Time` 类来演示对象指针、引用和数组，以及动态分配。

```c++
/* Test object pointer, reference and array (TestTimeObject.cpp) */
#include <iostream>
#include "Time.h"
using namespace std;
 
int main() {
   // Ordinary object
   Time t1(1, 2, 3);
   t1.print();  // 01:02:03
 
   // Object pointer
   Time* ptrT1 = &t1;
   (*ptrT1).print(); // 01:02:03
   ptrT1->print();   // 01:02:03
      // anObjectPtr->member is the same as (*anObjectPtr).member
 
   // Object reference
   Time& refT1 = t1; // refT1 is an alias to t1
   refT1.print();    // 01:02:03
 
   // Dynamic allocation
   Time* ptrT2 = new Time(4, 5, 6); // allocate dynamically
   ptrT2->print(); // 04:05:06
   delete ptrT2;   // deallocate
 
   // Object Array
   Time tArray1[2];    // tArray1 is an array of Time with 2 elements
                       // Use default constructor for all elements
   tArray1[0].print();  // 00:00:00
   tArray1[1].print();  // 00:00:00
 
   Time tArray2[2] = {Time(7, 8, 9), Time(10)}; // Invoke constructor
   tArray2[0].print();  // 07:08:09
   tArray2[1].print();  // 10:00:00
 
   Time* ptrTArray3 = new Time[2]; // ptrTArray3 is a pointer to Time
            // Dynamically allocate an array of Time with 2 elements via new[]
   ptrTArray3[0].print();  // 00:00:00
   ptrTArray3[1].print();  // 00:00:00
   delete[] ptrTArray3;    // Deallocate dynamic array via delete[]
 
   // C++11 syntax, compile with -std=c++0x
   Time* ptrTArray4 = new Time[2] {Time(11, 12, 13), Time(14)}; // Invoke constructor
   ptrTArray4->print();        // 11:12:13
   (ptrTArray4 + 1)->print();  // 14:00:00
   delete[] ptrTArray4;
}
```

## 4. 示例：Complex 类

![ClassDiagramComplex](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/ClassDiagramComplex.png)

一个类 `Complex` 模拟复数的设计如类图所示。它包含：

- 两个 `private` 数据成员： `real` 和 `imag` ，默认值为 0.0。
- 构造函数，私有数据成员的公共 getter/setter。
- `setValue()` 设置了 `real` 和 `imag` 。
- 一个 `public` 成员函数 `print()` ，它会打印 "(real, imag)"。
- `bool` 成员函数 `isReal()` 和 `isImaginary()` ，分别在 `imag` 为 0 和 `real` 为 0 时返回 true。
- `bool` 成员函数 `isReal()` 和 `isImaginary()` ，分别在 `imag` 为 0 和 `real` 为 0 时返回 true。
- `addReturnNew()` ，它将给定的复数（通过引用）与 `this` 实例相加，并返回一个新的 my complex 实例。 `this` 实例不应更改。

##### Complex.h

```c++
/* Header for the Complex class (Complex.h) */
#ifndef COMPLEX_H
#define COMPLEX_H
 
class Complex {
private:
   double real;
   double imag;
 
public:
   Complex(double real = 0.0, double imag = 0.0);
   double getReal() const;
   void setReal(double real);
   double getImag() const;
   void setImag(double imag);
   void setValue(double real, double imag);
   void print() const;
   bool isReal() const;
   bool isImaginary() const;
   // Add the given Complex instance into this instance, and return this instance by reference
   Complex & addInto(const Complex & another);
   Complex & addInto(double real, double imag);
   // Add the given Complex instance and this instance, return the sum in a new instance by value
   Complex addReturnNew(const Complex & another) const;
   Complex addReturnNew(double real, double imag) const;
};
 
#endif
```

##### Complex.cpp

```c++
/* Implementation for the Complex Class (Complex.cpp) */
#include <iostream>
#include "Complex.h"
using namespace std;
 
Complex::Complex(double real, double imag)
   : real(real), imag(imag) { }
 
double Complex::getReal() const {
   return real;
}
 
void Complex::setReal(double real) {
   this->real = real;
}
 
double Complex::getImag() const {
   return imag;
}
 
void Complex::setImag(double imag) {
   this->imag = imag;
}
 
void Complex::setValue(double real, double imag) {
   this->real = real;
   this->imag = imag;
}
 
// Print this Complex instance in the format of "x + iy"
void Complex::print() const {
   cout << '(' << real << ',' << imag << ')' << endl;
}
 
bool Complex::isReal() const {
   return (imag == 0);
}
 
bool Complex::isImaginary() const {
   return (real == 0);
}
 
// Add the given Complex instance into this instance and
//  return a reference of this instance
Complex & Complex::addInto(const Complex & another) {
   real += another.real;
   imag += another.imag;
   return *this;
}
 
Complex & Complex::addInto(double real, double imag) {
   this->real += real;
   this->imag += imag;
   return *this;
}
 
// Add the given Complex instance and return the sum in a new instance by value
Complex Complex::addReturnNew(const Complex & another) const {
   return Complex(real + another.real, imag + another.imag);
}
 
Complex Complex::addReturnNew(double real, double imag) const {
   return Complex(this->real + real, this->imag + imag);
}
```

##### 按引用返回 vs. 按值返回

`addInto()` 通过引用返回此实例（已在 `main()` 中构建并存在）。

`addReturnNew()` 构造一个 `Complex` 类的临时（局部）实例，并将此临时实例作为返回值传递。调用者接收并将临时实例复制到自己的变量中，通过逐成员赋值（即按值返回）。当函数返回时，临时局部实例超出作用域。

##### TestComplex.cpp

```c++
/* Test Driver for the Complex class (TestComplex.cpp) */
#include <iostream>
#include <iomanip>
#include "Complex.h"
using namespace std;
 
int main() {
   Complex c1, c2(4, 5);
   c1.print();  // (0,0)
   c2.print();  // (4,5)
 
   c1.setValue(6, 7);
   c1.print();  // (6,7)
 
   c1.setReal(0);
   c1.setImag(8);
   c1.print();  // (0,8)
 
   cout << boolalpha;  // print true/false instead of 0/1
   cout << "Is real? " << c1.isReal() << endl;           // false
   cout << "Is Imaginary? " << c1.isImaginary() << endl; // true
 
   c1.addInto(c2).addInto(1, 1).print();  // (5,14)
   c1.print();  // (5,14)
 
   c1.addReturnNew(c2).print();   // (9,19)
   c1.print();  // (5,14) - no change in c1
   c1.addReturnNew(1, 1).print(); // (6,15)
   c1.print();  // (5,14) - no change in c1
}
```

##### Don't Return a Reference of Local Variable 不要返回局部变量的引用

假设我们修改 `addReturnNew()` 以返回一个引用，如下所示：

```c++
Complex & Complex::addReturnNew(const Complex & another) const {
   return Complex(real + another.real, imag + another.imag);
}
```

您将收到此编译错误：“ `invalid initialization of non-const reference of type 'Complex&' from an rvalue of type 'Complex'` ”。这是因为在函数内部构造的临时局部变量会在函数返回时超出作用域并停止存在。调用者的引用变得无效。

## 5. 示例：Date 类

![ClassDiagramDate](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/ClassDiagramDate.png)

##### Date.h

```c++
/* Header for the Date class (Date.h) */
#ifndef DATE_H
#define DATE_H
 
#include <string>
using namespace std;
 
class Date {
private:
   int year;    // 1753-9999
   int month;   // 1-12
   int day;     // 1-31
   const static string STR_MONTHS[];
   const static string STR_DAYS[];
   const static int DAYS_IN_MONTHS[];
   const static int YEAR_MIN = 1753;
   const static int YEAR_MAX = 9999;
 
public:
   static bool isLeapYear(int y);
   static bool isValidDate(int y, int m, int d);
   static int getDayOfWeek(int y, int m, int d);
 
   Date(int y, int m, int d);
   void setDate(int y, int m, int d);
   int getYear() const;
   int getMonth() const;
   int getDay() const;
   void setYear(int y);
   void setMonth(int m);
   void setDay(int d);
   void print() const;
 
   Date & nextDay();
   Date & previousDay();
   Date & nextMonth();
   Date & previousMonth();
   Date & nextYear();
   Date & previousYear();
};
 
#endif
```

##### Date.cpp

```c++
/* Implementation for Date Class (Date.cpp) */
#include <iostream>
#include <stdexcept>
#include "Date.h"
using namespace std;
 
// Initialize static non-integer variable (must be done outside the class declaration)
const string Date::STR_MONTHS[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
const int Date::DAYS_IN_MONTHS[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 
const string Date::STR_DAYS[] = {"Sunday", "Monday", "Tuesday", "Wednesday",
                                 "Thursday", "Friday", "Saturday"};
 
// A static function that returns true if the given year is a leap year
bool Date::isLeapYear(int year) {
   return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));
}
 
// A static function that returns true if the given y, m, d constitutes a valid date
bool Date::isValidDate(int y, int m, int d) {
   if (y >= YEAR_MIN && y <= YEAR_MAX && m >= 1 && m <= 12) {
      int lastDayOfMonth = DAYS_IN_MONTHS[m-1];
      if (m == 2 && isLeapYear(y)) {
         lastDayOfMonth = 29;
      }
      return (d >= 1 && d <= lastDayOfMonth);
   } else {
      return false;
   }
}
 
// A static function that returns the day of the week (0:Sun, 6:Sat) for the given date
// Wiki "Determination of the day of the week" for the algorithm
int Date::getDayOfWeek(int y, int m, int d) {
   int centuryTable[] = {4, 2, 0, 6, 4, 2, 0, 6}; // 17xx, 18xx, ...
   int MonthTable[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5};
   int MonthLeapYearTable[] = {6, 2, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5};
 
   int century = y / 100;
   int twoDigitYear = y % 100;
   int centuryTableIndex = (century - 17) % 8;
   // Date before 17xx are not valid, but needed to prevent negative index
   if (centuryTableIndex < 0) {
      centuryTableIndex += 8;
   }
   int sum = centuryTable[centuryTableIndex] + twoDigitYear + twoDigitYear / 4;
   if (isLeapYear(y)) {
      sum += MonthLeapYearTable[m-1];
   } else {
      sum += MonthTable[m-1];
   }
   sum += d;
   return sum % 7;
}
 
// Constructor
Date::Date(int y, int m, int d) {
   setDate(y, m, d);
}
 
// With Input validation
void Date::setDate(int y, int m, int d) {
   setYear(y);
   setMonth(m);
   setDay(d); // need to set the day after year and month
}
 
int Date::getYear() const {
   return year;
}
 
void Date::setYear(int y) {
   if (y >= YEAR_MIN && y <= YEAR_MAX) {
      year = y;
   } else {
      throw invalid_argument("Error: Invalid year (1753-9999)!");
   }
}
 
int Date::getMonth() const {
   return month;
}
 
void Date::setMonth(int m) {
   if (m >= 1 && m <= 12) {
      month = m;
   } else {
      throw invalid_argument("Error: Invalid month (1-12)!");
   }
}
 
int Date::getDay() const {
   return day;
}
 
// Assuming that the year and month are already set
void Date::setDay(int d) {
   int lastDayOfMonth = DAYS_IN_MONTHS[month-1];
   if (month == 2 && isLeapYear(year)) {
      lastDayOfMonth = 29;
   }
   if (d >= 1 && d <= lastDayOfMonth) {
      day = d;
   } else {
      throw invalid_argument("Error: Invalid day (1-28|29|30|31)!");
   }
}
 
// Print this instance in the format "xxxday, d mmm yyyy".
void Date::print() const {
   cout << STR_DAYS[getDayOfWeek(year, month, day)] << ", "
        << day << " " << STR_MONTHS[month-1] << " " << year << endl;
}
 
// Increment this instance to the next day and return this instance by reference
Date& Date::nextDay() {
   int lastDayOfMonth = DAYS_IN_MONTHS[month-1];
   if (month == 2 && isLeapYear(year)) {
      lastDayOfMonth = 29;
   }
 
   // check day against the end of month
   if (++day > lastDayOfMonth) {
      day = 1;
      if (++month > 12) {
         month = 1;
         if (++year > YEAR_MAX) {
            throw out_of_range("Error: Next day is out of range!");
         }
      }
   }
   return *this;
}
 
// Decrement this instance to the previous day and return this instance by reference
Date& Date::previousDay() {
   int lastDayOfMonth = DAYS_IN_MONTHS[month-1];
   if (month == 2 && isLeapYear(year)) {
      lastDayOfMonth = 29;
   }
 
   // check day against the end of month
   if (--day < 1) {
      day = lastDayOfMonth;
      if (--month < 1) {
         month = 12;
         if (--year < YEAR_MIN) {
            throw out_of_range("Error: Previous day is out of range!");
         }
      }
   }
   return *this;
}
 
// Increment this instance to the next month and return this instance by reference
Date& Date::nextMonth() {
   if (++month > 12) {
      month = 1;
      if (++year > YEAR_MAX) {
         throw out_of_range("Error: Next month is out of range!");
      }
   }
   // may need to adjust the last day of the month
   int lastDayOfMonth = DAYS_IN_MONTHS[month-1];
   if (month == 2 && isLeapYear(year)) {
      lastDayOfMonth = 29;
   }
   if (day > lastDayOfMonth) {
      day = lastDayOfMonth;
   }
   return *this;
}
 
// Decrement this instance to the previous month and return this instance by reference
Date& Date::previousMonth() {
   if (--month < 1) {
      month = 12;
      if (--year < YEAR_MIN) {
         throw out_of_range("Error: Previous month is out of range!");
      }
   }
   // may need to adjust the last day of the month
   int lastDayOfMonth = DAYS_IN_MONTHS[month-1];
   if (month == 2 && isLeapYear(year)) {
      lastDayOfMonth = 29;
   }
   if (day > lastDayOfMonth) {
      day = lastDayOfMonth;
   }
   return *this;
}
 
// Increment this instance to the next year and return this instance by reference
Date& Date::nextYear() {
   if (++year > YEAR_MAX) {
      throw out_of_range("Error: Next year is out of range!");
   }
   // may need to adjust the last day of the month for leap year (29 Feb)
   //  to non-leap year (28 Feb)
   if (month == 2 && day == 29 && !isLeapYear(year)) {
      day = 28;
   }
   return *this;
}
 
// Decrement this instance to the previous year and return this instance by reference
Date& Date::previousYear() {
   if (--year < YEAR_MIN) {
      throw out_of_range("Error: Previous year is out of range!");
   }
   // may need to adjust the last day of the month for leap year (29 Feb)
   //  to non-leap year (28 Feb)
   if (month == 2 && day == 29 && !isLeapYear(year)) {
      day = 28;
   }
   return *this;
}
```

##### TestDate.cpp

```c++
/* Test Driver Program (TestDate.cpp) */
#include <iostream>
#include <stdexcept>
#include "Date.h"
 
int main() {
   Date d1(2012, 1, 1);
   d1.print();  // Sunday, 1 Jan 2012
   d1.nextDay().print();  // Monday, 2 Jan 2012
   d1.print();  // Monday, 2 Jan 2012
 
   d1.setDate(2012, 1, 31);
   d1.print();  // Tuesday, 31 Jan 2012
   d1.nextDay().print();  // Wednesday, 1 Feb 2012
 
   d1.setDate(2012, 2, 28);
   d1.print();  // Tuesday, 28 Feb 2012
   d1.nextDay().print();  // Wednesday, 29 Feb 2012
 
   d1.setDate(2012, 12, 31);
   d1.print();  // Monday, 31 Dec 2012
   d1.nextDay().print();  // Tuesday, 1 Jan 2013
 
//   Date d2(2011, 2, 29);  // abrupt termination!
//   d2.print();
 
   try {  // graceful handling of exception
      Date d3(2011, 2, 29);
      d3.print();
   } catch (invalid_argument &ex) {
      cout << ex.what() << endl;  // Error: Invalid day (1-28|29|30|31)!
   }
   cout << "Next Statement after try-catch" << endl;
 
   try {  // graceful handling of exception
      Date d4(9999, 12, 30);
      d4.nextDay().print(); // Friday, 31 Dec 9999
      d4.nextDay();
      d4.print();
   } catch (out_of_range &ex) {
      cout << ex.what() << endl;  // Error: Next day is outside the valid range!
   }
 
   Date d5(2012, 1, 1);
   d5.previousDay().print();  // Saturday, 31 Dec 2011
 
   Date d6(2012, 3, 31);
   d6.nextMonth().print();  // Monday, 30 Apr 2012
 
   Date d7(2012, 3, 31);
   d7.previousMonth().print();  // Wednesday, 29 Feb 2012
 
   Date d8(2012, 2, 29);
   d8.nextYear().print(); // Thursday, 28 Feb 2013
 
   Date d9(2012, 2, 29);
   d9.previousYear().print();  // Monday, 28 Feb 2011
}
```